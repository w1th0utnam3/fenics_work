import cffi
import importlib

import ufl
import ffc.compiler

from typing import List, Tuple


def compile_form(form: ufl.Form, prefix: str, extra_ffc_args=None) -> Tuple[str, str]:
    """Compiles an UFL form and returns the source code of the tabulate_tensor function."""

    prefix = prefix.lower()
    parameters = ffc.parameters.default_parameters()

    # Merge extra args into parameter dict
    if extra_ffc_args is not None:
        for key, value in extra_ffc_args.items():
            parameters[key] = value

    # For now, don't support lists of forms
    assert not isinstance(form, list)
    form_index = 0

    # Call FFC
    code_h, code_c = ffc.compiler.compile_form(form, prefix=prefix, parameters=parameters)

    # Build the concrete C function name of the generated function
    function_name = "tabulate_tensor_{}_cell_integral_{}_otherwise".format(prefix, form_index)
    # Find section of generated code that contains the tabulate_tensor function
    index_start = code_c.index("void {}(".format(function_name))
    index_end = code_c.index("ufc_cell_integral* create_{}_cell_integral_{}_otherwise(void)".format(prefix, form_index),
                             index_start)
    # Extract tabulate_tensor definition
    tabulate_tensor_code = code_c[index_start:index_end].strip()

    return function_name, tabulate_tensor_code


def compile_cffi(module_name: str,
                 code_c: str,
                 code_h: str,
                 compiler_args: List[str] = None,
                 verbose: bool = False) -> str:
    """Compiles a module from the specified source code using CFFI."""

    ffi = cffi.FFI()
    ffi.set_source(module_name, code_c, extra_compile_args=compiler_args)
    ffi.cdef(code_h)
    lib = ffi.compile(verbose=verbose)

    return lib


def import_cffi(module_name: str):
    """Imports a module generated by CFFI."""

    mod = importlib.import_module(module_name)
    ffi, lib = mod.ffi, mod.lib
    return ffi, lib
